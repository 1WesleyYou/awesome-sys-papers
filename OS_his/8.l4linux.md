## Review for "The Performance of $\mu$-Kernel-Based Systems"

Yuchen You (yuchenxr) & Sept. 8

### Assigned Questions

- Q: Compare and contrast the L4 microkernel with the RC 4000 (Nucleus) in terms of their goals to provide a basis on which higher level OS functionality can be implemented.
  - Goals:
    - RC 4000:
      - First idea of constructing a OS kernel that is small and contains primitives with internal process and IPC, and keeps all OS activities in the external process.
      - The nucleus provides only mechanisms, not policies.
      - The process management includes external supervisor to create subprocess,and thus form a tree-structured hierarchy of processes.
      - For scheduling, the nucleus only provides primitives for initiation and control of the processes, but leave the policy/strategy for scheduling for top system.
      - Allow all "operating systems" to be built as user-level subsystems on top of the nucleus, or say, one nucleus could support different OS personalities.
      - Motivation was flexibility: one nucleus could support time-sharing, batch, real-time, or other policies, depending on what supervisors were built.
    - L4:
      - Keep the higher level system structure not changed, and modify the microkernel to support the outer OS system. For the L4Linux, it modifies the L4 implementation for each Linux kernel apis so that it could run with the topper Linux System.
      - Serve as a _fast, lean_ basis for implementing L4Linux systems, or other personalities above it.
      - The kernel itself only maintains the basic idea of thread, address space and IPC. The higher-level OS like Linux will base on these primitives to construct its own functionality, like maintaining a software-level page table, and only when page fault occurs can the Linux server traps itself and ask the kernel to solve this fault with IPC forwarding.
      - The kernel itself support mostly the mechanisms but not much policies, e.g., for memory access, the microkernel only provides the secure mechanisms that prevent bad memory access requests, etc.
      - Make use of (optimize) the hardware/architecture features, like for the Pentium, which has the special optimization for small memory sharing and switching, to make the whole system, including the above software-level system work fast.
      - Iterrupt handler that supports priority(preemtion) and single threaded handler.
      - It found the bottleneck of the microkernel performance is mostly caused by the memory references, especially the TLB flush and cache miss, which is the key for the microkernel to solve based on the hardware features, but this also means the bad portability of the microkernel systems. But this is also the basis for other kernel systems to have good portability.
