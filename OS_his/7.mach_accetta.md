## Review for "Plan 9 from Bell Labs"

Yuchen You (yuchenxr) & Sept 3, 2025

- Q: What does it mean, "9P is really the core of the system; it is fair to say that the Plan 9 kernel is primarily a 9P multiplexer"?
  - A: The Plan 9 kernel's work is to route 9P file operations(like open/read/write/walk, etc.) from incoming (calling) processes to the correct back‑end—local filesystems and peripheral device drivers via direct procedure calls, or remote file servers via 9P RPC. Since every resources is unified as files with uniform interface to 9P protocol, so the Plan 9 kernel is primarily a 9P multiplexer that manages the multi-input/output of 9P messages between processes and resources.

## Review for "Mach: A New Kernel Foundation For UNIX Development"

### Motivation & goal

<!-- Abstract & First part of Introduction
    Abstract structure:
    1. Problem statement (Q1.1), including background and motivation (significance)
    2. Proposed solution (Q1.2)
    3. Evaluation & Result
-->

- What problem is this work addressing?
  <!-- first sentence of the abstract -->
  - UNIX kernel size is growing too large to meet the needs and technology of modern systems.
  - UNIX process combines the concept of a process and a thread, which combines the resource management with the execution
- Why the problem is important?
  <!-- background of the problem, reasons
      sentence after the above question
  -->
  - The complexity of the modern distributed environments and multiprocessor architectures
- What **goals** does this work aim to achieve?
  - Implement a Mach system with lightweight kernel
  - Provide a better abstraction of task, thread, port and message to achieve simplicity and efficiency (performance)

### Related SOTA work

- What are the state-of-the-art solutions addressing this problem?
  - UNIX system
  - CMU Accent system
- Why they are inadequate?
  <!-- SOTA Frame Name: shortback -->
  - The complexity of the modern distributed environments and multiprocessor architectures
  - The UNIX kernel has been growing too large to meet the needs and technology of modern systems
  - The CMU Accent system is uniprocessor only

### Idea & insight

<!-- Idea & Insight: Second part of the Introduction
    Second part of Intro will show the tools/algos the work uses (the insights, background principles of their work but not the implementation, which is the third part)
-->

- What is the key idea of this work?
  - 4 key abstractions:
    - task: execution environment with which threads may run
    - thread: basic unit of CPU utilization, or the execution stream of a CPU
    - port: communication channel between tasks, or the interface of the object abstraction
    - message: typed collection of data objects in communication between tasks
    <!-- Tool/Algo name: function statement -->
- What is the insight, if any, behind this idea?
  <!-- Insight: background principles, why it works -->
  - task and thread: separation of the resources management and the execution management
  - unified view of local and remote objects

### Solution

<!-- Solution: it should be found in the Method/Design section
    For the design overview in the Intro part, it's too general, but in Design section it should be concrete enough.
    It's very important to read the flow chart/diagrams in this section, usually the solutions are presented visually.
-->

- Roughly speaking, how does the solution work?
<!-- read the figure (flow chart) -->
- What are the key techniques and algorithms used in the solution?
<!-- read the bullet point/bold text in the introduction, they should be listed as keywords there -->

### Assumption & limitations

<!-- Assumption keyword:
    1. we believe ...
    2. suppose
    3. assume
    4. suggest
-->

<!-- Limitation keyword:
    1. restrict
    2. consider
    3. focus on
    4. ignore
    5. limit
    6. model
-->

- What assumptions do the proposed solution make?
  - The system is based on a multiprocessor architecture but could also run on a light uniprocessor system.
- Are these assumptions reasonable? Are there any assumption that the authors did not describe in the paper?
  - Reasonable.

### Effectiveness

<!-- Evaluation Section and Related Work
    1. Evaluation:
      - Setup: datasets, metrics, baselines
    2. Analysis:
      - Result back up the hypothesis
      - Error analysis, etc.
-->

- What experiments, analyses are conducted to evaluate the solution?
  <!-- setup, eval method (data process) -->
  - The MicroVAX II cost of touching newly allocated memory is less than 0.7 milliseconds per 1024 bytes of data

### Historical papers only

- What historical context (e.g., hardware trend) was the work in?
  - Multiprocessor architecture are more advanced and common
  - System kernel is growing larger
- Is the paper still relevant for today?
  - Yes, I think the abstraction of port and message is still been used.

### Conclusion

- What conclusion do you draw from this work?
  - The Mach system provides a lightweight kernel with better abstractions of task, thread, port and message to achieve simplicity and efficiency (performance).

### Assigned paper questions

- Q: How do Mach's goals and its "port" abstractions compare with RC 4000's?
  - Mach's goal：
    - abstraction of task, thread, port and message
    - provide a better support for multiprocessor and distributed systems
    - unified view of local and remote objects
  - RC 4000's goal：
    - devide the task of the OS into the Nucleus and the user mode
    - nucleus should support parallel processes and inter-process communication
    - nucleus is responsible for resource allocation and scheduling
  - Mach's port abstraction：
    - interface to control the task/thread
    - the basic transportation abstraction, and a protected kernel object
    - logically port is a finite length queue of messages sent by other tasks
  - RC 4000's port abstraction：
    - for ipc, RC4000 has a design similar to the port abstraction: it maintains a FIFO buffer for each communication
    - the port can only be used to sync the processes but not other control over the process
    - the internal parent process could control the child process,
    - not that object-oriented as Mach's port
