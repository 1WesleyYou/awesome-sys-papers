## Review for "The Rise of 'Worse is Better', Richard Gabriel"

Yuchen You, Aug 30, 2025

### Motivation & goal

- What problem is this work addressing?
  - This work explains the phenomenon that "worse is better" in software design, where simpler, less feature solutions or languages like C and Unix (New Jersey Approach) can outperform more complex ones like Lisp and CLOS (MIT Approach).
- Why the problem is important?
  - Previous most research is trying to make systems more complex and richer in features, but this approach can lead to over-engineering and unnecessary complications.
  - In reality, the most modern, complex and feature-rich language/system, the Lisp/CLOS, often fails in building practical os but on the other hand, simpler languages like C have been more successful in this domain.
- What goals does this work aim to achieve?
  - This work tries to explain the "worse is better" phenomenon and try to convince programmers to consider this as a new design philosophy.

### Related work

- What are the state-of-the-art solutions addressing this problem?
  - No SOTA work
- Why they are inadequate?
  - N/A

### Idea & insight

- What is the key idea of this work?
  - The key idea is that simpler, less feature designs and solutions can be more effective and practical than complex ones in software designing, encapsulated in the phrase "worse is better."
- What is the insight, if any, behind this idea?
  - The 'big complex system' scenario: the literally right thing takes nearly 100% of desired functionality and the last 20% takes nearly 80% of the effort to implement.
- Why _might_ this idea be better than prior work?
  - This idea challenges the conventional wisdom that pursues 'perfect' in software design, and encourages a focus on simplicity and practicality.

### Solution

- Roughly speaking, how does the solution work?
  - N/A
- What are the key techniques and algorithms used in the solution?
  - N/A

### Assumption & limitations

- What assumptions do the proposed solution make?
  - N/A
- Are these assumptions reasonable? Are there any assumption that the authors did not describe in the paper?
  - N/A
- What limitations does this solution have?
  - N/A

### Effectiveness

- What experiments, analyses are conducted to evaluate the solution?
  - N/A
- Do these results and analyses back up the paper's claims?
  - N/A
- Are there any missing aspects in the evaluation?
  - N/A

### Comparison

- How does this work compare with some other works we have read/discussed?
  - N/A
- Does it take a radically different approach or draw a surprising conclusion?
  - No
- Or is it more or less in line with the direction in the other works?
  - N/A

### Learning & thoughts

- Are you convinced that the proposed idea/solution is good?
  - Yes, I think today's software design often prioritizes simplicity and practicality over unnecessary complexity.
- If not, what flaws you see in the work that can be improved?
  - N/A
- What are the new things you learned from this paper?
  - The concept of "worse is better" and its implications for software design.

### Unanswered questions

- What questions are you left with?
  - What are more practical examples of the "worse is better" phenomenon in software design in later/recent year?
- Are there any confusing parts of the paper that are not addressed?
  - Is there any successful design practice of "better is better"?
- If you were the authors, is there anything you would do differently?
  - Add more example and practical case studies to support the claims (but not pure story telling).

### Historical papers only

- What historical context (e.g., hardware trend) was the work in?
  - A lot of software developer and language designer believe that a system/language with more feature and complexity is inherently better, leading to the development of more advanced and feature-rich languages like Lisp and CLOS.
- What things you were taking for granted but now understand how they came to be?
  - Why the os are designed in C but not other (more advanced/modern) languages -> for simplicity and easy usage.
- Is the paper still relevant for today?
  - Yes, the principles of simplicity and practicality in software design are timeless and continue to be relevant in today's development practices.

### Conclusion

- What conclusion do you draw from this work?
  - The "worse is better" phenomenon highlights the importance of simplicity and practicality in software design, suggesting that less complex solutions can often be more effective.
- What are the main take-away messages?
  - Simplicity and easy use should be prioritized over feature and complexity in software design.
- Can you relate to the findings/solutions/results from your own experience?
  - Yes, over simplification can lead to a lack of necessary features and capabilities, and a more easy and simple solution could lead to a more adaptable system.
- How may this work influence the way we build systems in the future?
  - Design choices should not be too complex or pursue unnecessary features, but rather focus on practicality and ease of use.
